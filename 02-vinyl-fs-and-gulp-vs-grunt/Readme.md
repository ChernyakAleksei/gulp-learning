#Потоки в Node.js, Vinyl-FS и Gulp vs Grunt

###Потоки в Node.js
Перед тем как двигаться дальше, давайте отвлечемся немного от `gulp` и поговорим про потоки в **Node.js**. Мы не будем глубоко вникать в тему потоков, просто коснемся ее для понимания того, как устроен `gulp` и его сердце - модуль `Vinyl-FS`.
Объект `stream` в **Node.js** представляет собой универсальный интерфейс для работы с потоками данных. Если говорить еще проще, то поток - это обычный javascript объект, который хранит в себе информацию о ресурсе (например, файле) и умеет с ней работать.
Потоки бывают нескольких типов: Readable, Writable, Duplex и Transform. Но нам для понимания `gulp` понадобятся первые два. `stream.Readable` - служит для чтения данных, `stream.Writable` - для записи.
Давайте создадим `Readable` поток и посмотрим на него. Создадим файл `stream.js`, подключим в него модуль `fs`, стандартный **Node.js** модуль для работы с файловой системой и напишем простой код, для чтения данных из источника (в нашем случае это файл):
```js
// Подключим модуль для работы с файловой системой
const fs = require('fs');

// Создадим поток для чтения данных из файла
const stream = new fs.createReadStream('files/file.txt');

// Навесим обработчик на событие 'readable' - которое возникает,
// когда данные возможно прочитать из буфера потока.
// С помощью метода read() обьекта потока читаем данные и выводим их в консоль.
stream.on('readable', () => {
  let chunk;
  while (null !== (chunk = stream.read())) {
    console.log(`'Readable' event: ${chunk}`);
  }
});

// В свою очередь, когда источник данных иссяк, возникает событие 'end',
// которое сигнализирует о завершении чтения данных из потока,
// т.е буфер потока попросту пуст.
stream.on('end', () => console.log(`'End' event: 'Reading stream has finished.'`));
```
Замечу, что помимо создания самого обьекта потока, мы навешиваем несколько обработчиков событий: 'readable' и 'end'. Событие 'readable' возникает в тот момент, когда данные из файла или другого источника прочитаны и находятся во внутреннем буфере потока и, как следствие, их возможно прочитать. Событие 'end' возникает в момент, когда буфер потока пуст и больше нечего читать из источника. Запустим код:
```sh
$ node stream.js
```
Как видно, сначала отработал обработчик события 'readable' - вывев все прочитанные данные из файла, а затем событие 'end' сигнализировало о завершении чтения из источника и завершении работы потока.
Казалось бы ничего необычного, все закономерно. А теперь, давайте прочитаем файл по-больше, для этого укажем потоку на другой ресурс и будем выводить не содержимое файла, а размер куска буфера:
```js
// создадим поток для чтения большого файла
const stream = new fs.createReadStream('files/big-file.txt');
...
stream.on('readable', () => {
  let chunk;
  while (null !== (chunk = stream.read())) {
    // будем выводить размер одного куска, вместо содержимого
    console.log(`'Readable' event: ${chunk.length}`);
  }
});
```
Запустим файл:
```sh
$ node stream.js
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 65536
'Readable' event: 17429
'End' event: 'Reading stream has finished.
```
Хм, как видно событие 'readable' сработало аж 15 раз. В чем причина? А причина очень проста - поток не читает файл (ресурс) полностью, он делает это по частям (кускам). Прочитав одну часть - он отдает ее дальше, когда следующий обработчик данных ее получит (в нашем случае мы выводим данные в консоль), поток освобождает свой внутренний буфер и зачитывает еще часть данных и так до тех пор, пока все данные не будут прочитаны из источника. Второй вывод, который можно сделать - это то, что максимальный размер буфера потока 65536 байт. И третий, немаловажный вывод - потоки экономят память, файл (источник) может быть сколь угодно большого размера, но за 1 раз будет прочитана лишь незначительная его часть, таким образом, к примеру, медленный клиент не сможет полностью уничтожить память нашего сервера.

А как обстоят дела с `stream.Writable`? **Writable** поток, также имеет свои свойства, методы и события, но поскольку мы договаривались особенно не углубляться в работу потоков, для отправки данных из **readable** stream, мы будет использовать его стандартный метод `pipe()`. Метод `pipe()` потока **readable**, связывает друг с другом **readable** и **writable** потоки, а также берет на себя автоматическое управление буферами обоих потоков, слушая события **readable** потока и управляя передачей данных в **writable** поток, таким образом, например, чтение данных с сервера и доставка их клиенту будет происходить без сбоев. К тому же, с помощью метода `pipe()` можно писать более краткий, понятный и лаконичный код. Давайте попробуем.
Для этого нам понадобится еще один стандартный **Node.js** модуль - `http`. Подключим его и напишем простой сервер, который будет слушать 3000 порт и по запросу '/', будет отдавать содержимое файла `big-file.txt`:
```js
// Подключим модуль для работы с файловой системой
const fs = require('fs');

// Подключим модуль 'http'
const fs = require('fs');

// напишем функцию, которая будет зачитывать файл и через метод pipe()
// отсылать содержимое клиенту
const sendFileContent = (res) => {
  // содаем поток для чтения файла
  const stream = new fs.createReadStream('files/file.txt');
  // отсылаем содержимое клиенту
  stream.pipe(res);
};

// создаем сервер, который на http запрос на '/', будет формировать загловки
// и вызывать функцию, которая будет отсылать клиенту содержимое файла
const server = http.createServer((req, res) => {
  if (req.url === '/') {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    sendFileContent(res);
  }
});

// сервер слушает порт 3000, хост 127.0.0.1
server.listen(3000, '127.0.0.1', () => {
  console.log('Server running at http://127.0.0.1:3000/');
});
```
Запустим наш код:
```sh
$ node stream.js    "http": "0.0.0"
```
Перейдем в браузер и в адресной строке наберем `http://127.0.0.1:3000/`. Как видим, отобразирось содержимое нашего файла. У такого подхода есть еще один неоспоримый плюс, метод `pipe()` позволяет организовать несколько выходных потоков, давайте немного дополним наш код, а именно дополним нашу функцию `sendFileContent()` еще одной цепочкой для отображения содержимого нашего файла в стандартном потоке вывода:
```js
...
// напишем функцию, которая будет зачитывать файл и через метод pipe()
// отсылать содержимое клиенту
const sendFileContent = (res) => {
  // содаем поток для чтения файла
  const stream = new fs.createReadStream('files/file.txt');
  // отсылаем содержимое клиенту
  stream.pipe(res);
  // отображение содержимого файла в стандартном потоке вывода
  stream.pipe(process.stdout);
};
...
```
Итак, мы бегло познакомились с потоками, но эта пусть и краткая информация поможет нам лучше понять и разобраться с `gulp`, а именно с его внутренним устройством и почему он быстрее `grunt`. Но обо всем, по порядку.

###Vinyl-FS
Что же такое этот `Vinyl-FS`? Во-первых - это адаптер или модуль, который, скажем так, конвертирует каждый полученный на обработку файл (ресурс) в объект типа **vinyl**, со своим набором метаданных. Во-вторых, без преувеличения, это сердце `gulp`.

Давайте ближе взглянем на то, в каком виде **Vinyl-FS** представляет наши даные. Для этого напишем простую задачу, которая будет копировать файлы из одной директории в другую.
```js
const gulp = require('gulp');

gulp.task('copy', () => {
  gulp.src('src/**/*.*')
    .pipe(gulp.dest('build'));
});
```
Запустим её:
```sh
$ gulp copy
[15:22:35] Using gulpfile ~/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt/gulpfile.js
[15:22:35] Starting 'copy'...
[15:22:35] Finished 'copy' after 9.84 ms
```
Файлы скопированы в папку **build** с сохранением структуры поддиректорий. А теперь добавим в наш код обработчик на стандартное событие для **readable** потока 'data', который в явном виде будет выводить в консоль все файлы, проходящие через поток:
```js
const gulp = require('gulp');

gulp.task('copy', () => {
  gulp.src('src/**/*.*')
    // обработчик события 'data', который будет выводить все файлы,
    // проходящие через поток
    .on('data', (file) => console.log(file))
    .pipe(gulp.dest('build'));
});
```
Запустим код:
```sh
$ gulp copy
[15:29:20] Using gulpfile ~/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt/gulpfile.js
[15:29:20] Starting 'copy'...
[15:29:20] Finished 'copy' after 10 ms
<File "hello.js" <Buffer 63 6f 6e 73 74 20 73 61 79 48 65 6c 6c 6f 20 3d 20 77 68 6f 20 3d 3e 20 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 60 48 65 6c 6c 6f 2c 20 24 7b 77 68 6f 7d ... >>
<File "css/body.css" <Buffer 62 6f 64 79 20 7b 0a 20 20 6d 61 72 67 69 6e 3a 20 30 20 61 75 74 6f 3b 0a 20 20 77 69 64 74 68 3a 20 31 32 30 30 70 78 3b 0a 20 20 62 61 63 6b 67 72 ... >>
<File "css/headers.css" <Buffer 68 31 20 7b 0a 20 20 63 6f 6c 6f 72 3a 20 23 66 66 33 66 34 31 3b 0a 7d 0a 0a 68 32 20 7b 0a 20 20 63 6f 6c 6f 72 3a 20 23 35 31 34 30 66 66 3b 0a 7d ... >>
```
Мы видим имя файла и буфер потока, так как поток - это лишь набор бинарных данных.
А теперь давайте у `file` вызовем метод `toString()`:
```js
const gulp = require('gulp');

gulp.task('copy', () => {
  gulp.src('src/**/*.*')
    .on('data', (file) => console.log(file.toString()))
    .pipe(gulp.dest('build'));
});
```
Запустим код еще раз:
```sh
$ gulp copy
[15:34:38] Using gulpfile ~/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt/gulpfile.js
[15:34:38] Starting 'copy'...
[15:34:38] Finished 'copy' after 11 ms
[object Object]
[object Object]
[object Object]
```
И видим то, о чем говорилось ранее - `gulp` внутри себя оперирует объектами типа **vinyl**. А из чего состоит этот обьект? Давайте посмотрим:
```js
const gulp = require('gulp');

gulp.task('copy', () => {
  gulp.src('src/**/*.*')
    .on('data', (file) => console.log({
      contents: file.contents,
      path:     file.path,
      cwd:      file.cwd,
      base:     file.base,
      relative: file.relative,
    }))
    .pipe(gulp.dest('build'));
});
```
Запустим код:
```sh
$ gulp copy
[15:52:06] Using gulpfile ~/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt/gulpfile.js
[15:52:06] Starting 'copy'...
[15:52:06] Finished 'copy' after 10 ms
{ contents: <Buffer 63 6f 6e 73 74 20 73 61 79 48 65 6c 6c 6f 20 3d 20 77 68 6f 20 3d 3e 20 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 60 48 65 6c 6c 6f 2c 20 24 7b 77 68 6f 7d ... >,
  path: '/home/anton/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt/src/hello.js',
  cwd: '/home/anton/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt',
  base: '/home/anton/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt/src/',
  relative: 'hello.js' }
...
```
Также за кадром остались ряд, других свойств и методов объекта **vinyl**, но они не так нам важны. Из данного примера видно за счет чего происходит сохранение структуры файлов и поддиректорий: метод `dest()` берет путь из свойства потока **cwd**, добавляет в нему указанный нами путь и плюсует данные из свойства **relative** обьекта потока.
Давайте немного заглянем под капот `gulp` и посмотрим откуда берутся эти обьекты **vinyl**. Перейдем в папку **node_modules/gulp** и откроем файл **index.js**:
```js
var vfs = require('vinyl-fs');
...
Gulp.prototype.src = vfs.src;
Gulp.prototype.dest = vfs.dest;
```
Мы видим, что методы `src()` и `dest()` не что иное, как методы модуля `vinyl-fs`.
Стоит сделать еще одно немаловажное замечание - вызовы методов `src()` и `pipe()` возвращают потоки, таким образом можно строить цепочки обработки данных.
И последнее, текущая версия `gulp` (3.9.1) использует `vinyl-fs` версии `0.3.14`, хотя на сегодняшний день эта библиотека уже имеет стабильную версию `2.4.3 `, обратите на это внимание при написании тасков, некоторые возможности новой версии библиотеки `vinyl-fs` не доступны в текущей (3.9.1) версии `gulp`.

###Разделение обрабатываемых файлов по разным папкам
Метод `gulp.dest()` может принимать аргументом функцию, которая должна вернуть имя папки для результирующих файлов. Изменим немного наш код:
```js
...
gulp.task('copy', () => {
  gulp.src('src/**/*.*')
    .pipe(gulp.dest((file) => {
      return (~file.relative.indexOf('.js')) ? 'js' :
        (~file.relative.indexOf('.css')) ? 'css' : 'build';
    }));
});
```
и запустим его:
```sh
$ gulp copy
[16:42:17] Using gulpfile ~/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt/gulpfile.js
[16:42:17] Starting 'copy'...
[16:42:17] Finished 'copy' after 10 ms
```
После выполнения задачи создастся две папки `css` с файлами стилей и `js` со скриптами, папки `build` не будет, т.к. других файлов у нас нет. Если добавить еще один файл в папку `src`, например, `text.txt` и перезапустить задачу, мы увидим, данный файл скопируется именно в папку `build`.

###Пути и паттерны для `gulp.src()`
Метод `gulp.src()` может принимать путь как в виде строки, так и в виде массива. Обрабатывает паттерны (маски) передаваемых путей - библиотека `node-glob`, ссылка на нее чуть ниже.
Представим, что помимо папки `src`, есть папка `src2` из которой также необходимо обработать файлы. Давайте напишем задачу, с помощью которой это можно осуществить:
```js
...
gulp.task('copy', () => {
  gulp.src(['src/**/*.*', 'src2/**/*.*'])
    .pipe(gulp.dest('build'));
});
```
Запустим ее и увидим, что помимо файлов из папки `src` папку `build` скопировались файлы и из `src2`. Замечу, что при таком подходе файлы (папки) будут обрабатываться в том порядке, в котором они указаны в массиве.

###Еще немного про `gulp.task()`
Метод `gulp.task()` вторым аргументом может принимать массив задач, которые выполняться перед тем, как запуститься основной таск. Рассмотрим пример:
```js
const gulp = require('gulp');

gulp.task('first', ['copy'], () => {
  console.log('first task done...')
});

gulp.task('copy', () => {
  gulp.src('{src,src2}/**/*.*')
    .pipe(gulp.dest('build'));
});
```
Запустим задачу:
```sh
$ gulp first
[18:09:39] Using gulpfile ~/projects/gulp-learning/02-Vinyl-FS-and-gulp-vs-grunt/gulpfile.js
[18:09:39] Starting 'copy'...
[18:09:39] Finished 'copy' after 12 ms
[18:09:39] Starting 'first'...
first task done...
[18:09:39] Finished 'first' after 35 μs
```
Как видим первым выполнилась задача `copy`, затем отработал таск `first`. Важно помнить, что для успешного выполнения, каждая задача должна принимать коллбэк или возвращать промис или объект потока. Также немаловажно знать, что все задачи запустятся НЕ поочередно, а параллельно!

###Gulp vs Grunt
И наконец в завершении этой главы, сравним `gulp` с не менее популярным инстурментом `grunt`. Помимо субьективных отличий, таких как: более лаконичный и красивый код получается на `gulp` или встречаются высказывания - 'на `gulp` мы пишем javascript, а на `grunt` файл конфигурации', есть одно очень важное различие, которое существенно отличает эти два практически одинаковых таск раннера. Давайте заглнем в папку `gulp-vs-grunt` и сравним оба конфига. Проанализировав их можно сделать вывод, что: `grunt` обрабатывает файлы используя диск, то есть, к примеру, он читает все `*.scss` файлы, анализирует их, трансформирует код в обычный `*.css` и отдает далее на обработку плагину `autoprefixer`, после работы которого, готовые файлы попадают в конечную директорию. Как известно дисковые операции достаточно дорогие, поэтому `gulp` используя исключительно память и всю мощь потоков производит обработку файлов значительно быстрее.

### Полезные ссылки
* [Потоки в Node.js](https://nodejs.org/dist/latest-v6.x/docs/api/stream.html)
* [Еще про потоки](https://github.com/substack/stream-handbook)
* [Vinyl-fs](https://github.com/gulpjs/vinyl-fs)
* [gulp.task()](https://github.com/gulpjs/gulp/blob/master/docs/API.md#gulptaskname--deps--fn)
* [node-glob](https://github.com/isaacs/node-glob)
* [gulp.src()](https://github.com/gulpjs/gulp/blob/master/docs/API.md#gulpsrcglobs-options)
* [gulp.dest()](https://github.com/gulpjs/gulp/blob/master/docs/API.md#gulpdestpath-options)
